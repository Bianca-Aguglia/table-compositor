'''
Module that supports operations to map a dataframe to an excel worksheet like entity
and also create Excel files with all fancy formatting.
'''

# TODO:
# a. Feature to Hide columns/indices
# b. Tests
# c. HTML Writer (non-nested, and then nested tables)
# e. Revisit _convert method


from itertools import groupby
from itertools import product
from collections import deque
from collections import defaultdict
from collections import namedtuple

import pandas as pd
import numpy as np

StyleWrapper = namedtuple('StyleWrapper', ['user_style'])

PresentationAndLoc = namedtuple('PresentationAndLoc', ['model', 'locs'])
Locs = namedtuple(
    'Locs', ['header_loc', 'index_loc', 'data_loc', 'index_name_loc', 'nesting_level'])

PresentationElements = namedtuple('PresentationElements', ['values', 'style'])

# The header, index_label, data and index_name attributes in the presentation
# model will be of type PresentationElements
PresentationModel = namedtuple(
    'PresentationModel',
    ['header', 'index_label', 'data', 'index_name', 'kwargs'])

LocOffsets = namedtuple(
    'LocOffsets', ['start_row', 'start_col', 'end_row', 'end_col'])

ValueAndStyleAttributes = namedtuple(
    'ValueAndStyleAttributes', ['value', 'style_wrapper', 'nesting_level'])

def default_offsets(start_row, start_col):
    return LocOffsets(
        start_row=start_row,
        start_col=start_col,
        end_row=start_row,
        end_col=start_col)

class GridLayoutManager:
    '''
    Contains methods related to resolving the input layout. An input layout
    has to be transformed into a Grid. Each cell in the grid represents a df
    or cells may be empty depending on the layout.

    The same layout is used to resolve max ht and max width and placed in the
    same location in a newly created grid.

    Can to apply function returns a new grid. The Grids provided to most of the
    functions in this class are not mutated, but a new version of the grid is
    returned.  '''

    @staticmethod
    def layouts_to_grid(layouts, horizontal=False):
        '''
        Given the layouts, return a Grid (list of lists) with PresentationModels
        placed in the appropriate cells in the grid.

        Args:
            layouts:Nested list of PresentationModels that represents the
            placement of each model in the display
            horizontal: The outermost orientation. For every inner list
            encountered the orientation is flipped.
        '''
        d, _, _ = GridLayoutManager._compute_row_col_grid(
            layouts, horizontal=horizontal)
        grid = GridLayoutManager._make_row_col_grid(d, default_value=None)
        return grid

    @staticmethod
    def apply_func_to_grid(grid, func, inplace=False, default=None):
        '''
        Apply the function func to each cell in the grid. Ignore calling
        the func when an `default` value is encountered.

        Args:
            grid: A list of list representing the grid. The values in each
            cell in the grid will depend on the grid the function is being
            applied to.
            func: The func that will be applied to each value in the grid. The
            func will be called with (row, col) index of the value in the list of lists
            and the value at (row, col) in the grid.
        '''
        new_grid = grid
        if not inplace:
            new_grid = [[default] * len(grid[0]) for _ in range(len(grid))]

        for i, values in enumerate(grid):
            for j, value in enumerate(values):
                new_grid[i][j] = func(i, j, value) if value else default
        return new_grid

    @staticmethod
    def _compute_grid_bounds(grid, func):
        '''
        Return the max row and cols across each row and column in the grid.

        Args:
            grid: List of List where each value is of type PresentationModel
            func: apply func to values in grid to get (max_rows, max_cols) within
            each cell
        '''

        grid = GridLayoutManager.apply_func_to_grid(grid, func, default=(0, 0))
        max_rows = [max(j) for i in grid for k,
                    j in enumerate(zip(*i)) if k % 2 == 0]
        max_cols = [max(j) for i in zip(*grid)
                    for k, j in enumerate(zip(*i)) if k % 2 == 1]

        cum_rows = np.cumsum(max_rows) + range(1, len(max_rows) + 1)
        cum_cols = np.cumsum(max_cols) + range(1, len(max_cols) + 1)
        return cum_rows.tolist(), cum_cols.tolist()

    @staticmethod
    def resolve_grid(layouts, orientation='vertical'):
        '''
        Entry point function, that will return a PresentationAndLoc instance
        placed in each cell of the grid (or None) if that cell does not
        have any placement.

        Args:
        layouts: return value of layouts to grid
        horizontal: default orientation of outermost list.
        '''

        horizontal = orientation.upper() == 'HORIZONTAL'
        f = lambda i, c, x: (
            PresentationLayoutManager.height(
                x.data.values, x.kwargs['hide_header']),
            PresentationLayoutManager.width(x.data.values, x.kwargs['hide_index']))

        grid = GridLayoutManager.layouts_to_grid(layouts, horizontal)
        cum_rows, cum_cols = GridLayoutManager._compute_grid_bounds(grid, f)

        # first resolve locs independently for each
        # element in the grid
        for i, values in enumerate(grid):
            for j, value in enumerate(values):
                if not value:
                    grid[i][j] = None
                else:
                    grid[i][j] = PresentationLayoutManager.resolve_loc(value)

        def shifter(i, j, presentation_and_loc):
            if (i, j) == (0, 0):
                return presentation_and_loc  # we do not shift the first frame
            # nonlocal cum_rows
            # nonlocal cum_cols

            # FIXME: This 2 can be made configurable
            rows = cum_rows[i - 1] if i > 0 else 0
            cols = cum_cols[j - 1] if j > 0 else 0

            return PresentationLayoutManager.shift_loc(
                presentation_and_loc, rows=rows, cols=cols)

        new_grid = GridLayoutManager.apply_func_to_grid(
            grid, shifter, default=None)

        return new_grid

    @staticmethod
    def get_row_col_dict(layouts, orientation='vertical'):
        shifted_grid = GridLayoutManager.resolve_grid(
            layouts, orientation=orientation)
        return GridLayoutManager.to_row_col_dict_from_grid(
            shifted_grid, nested=False)

    @staticmethod
    def _make_row_col_grid(grid_dict, default_value=0, f=lambda x: x):
        '''
        Initialize a grid with default values using the size of the passed in
        grid. Use to create an copy thus providing some immutability.

        Args:
            grid_dict: (row, col)
        '''

        max_row = max(v[0] for v in grid_dict.keys())
        max_col = max(v[1] for v in grid_dict.keys())
        grid = [[default_value] * (max_col + 1) for _ in range(max_row + 1)]
        for k, v in grid_dict.items():
            #print(k, v)
            grid[k[0]][k[1]] = f(v)
        return grid

    @staticmethod
    def _compute_row_col_grid(
            layout,
            f=lambda x: x,
            horizontal=False,
            level=0,
            col=0):
        '''
        Computes the placement of each value in the layout based on its
        relative nesting in the `layout` argument.

        Args:
            layout: a nested list of PresentationModels representing the layout
            f: func to apply. This can be used to delay creation of LayoutMolde like
            objects until later
            horizontal: treats vertical alignment for any encountered list
        '''
        d = {}
        _col = col
        _level = level
        for m in layout:
            if isinstance(m, (list,)):
                _d, _level, _col = GridLayoutManager._compute_row_col_grid(
                    m, f, (not horizontal), level, col)
                d.update(_d)
                if horizontal:
                    col = _col + 1
                else:
                    level = _level + 1
                #print('here', level, col, _level, _col, horizontal)
            else:
                d[(level, col)] = f(m)
                if horizontal:
                    col += 1
                else:
                    level += 1
        #print(d, level, col)
        return (d, max(level - 1, _level), max(col - 1, _col))


    @staticmethod
    def to_row_col_dict_from_grid(grid, nested=False):
        '''
        Return a dict representation of the grid. This can be called
        once the grid
        '''
        row_col_dict = {}

        def collect_row_col_dict(i, c, value):
            nonlocal row_col_dict
            row_col_dict.update(
                    GridLayoutManager.to_row_col_dict(value, row_col_dict, nested=nested))
            return row_col_dict

        GridLayoutManager.apply_func_to_grid(grid, collect_row_col_dict)

        return row_col_dict

    @staticmethod
    def to_grid_with_row_col_dicts(grid):
        '''
        Populate the grid with respective rol_col_dict values.
        The row_col_dict is not consolidated in comparison to to_row_col_dict_from_grid
        '''
        def compute_row_col_dict(i, c, value):
            return GridLayoutManager.to_row_col_dict(value, None)
        new_grid = GridLayoutManager.apply_func_to_grid(
            grid,
            compute_row_col_dict)
        return new_grid

    @staticmethod
    def to_row_col_dict(view_and_loc, row_col_dict=None, nesting_level=0, nested=False):
        presentation_model = view_and_loc.model
        locs = view_and_loc.locs

        row_col_dict = row_col_dict if row_col_dict is not None else {}
        header_locs = locs.header_loc
        data_locs = locs.data_loc
        index_locs = locs.index_loc
        index_name_loc = locs.index_name_loc

        if index_name_loc:
            row_col_dict[LocOffsets(*index_name_loc)] = (
                ValueAndStyleAttributes(
                    presentation_model.index_name.values,
                    presentation_model.index_name.style, nesting_level))

        if header_locs:
            data = IndexNode.gather_data(
                header_locs,
                presentation_model.header.values,
                presentation_model.header.style).values()
            data = {LocOffsets(*offsets): ValueAndStyleAttributes(
                value, style, nesting_level)
                for offsets, value, style in data}
            row_col_dict.update(data)

        if index_locs:
            data = IndexNode.gather_data(
                index_locs,
                presentation_model.index_label.values,
                presentation_model.index_label.style).values()
            data = {LocOffsets(*offsets): ValueAndStyleAttributes(
                value, style, nesting_level)
                for offsets, value, style in data}
            row_col_dict.update(data)


        for i in presentation_model.data.values.index:
            for c in presentation_model.data.values.columns:
                offsets = data_locs.loc[i, c]
                if isinstance(offsets, PresentationAndLoc):
                    inner_view_and_locs = data_locs.loc[i, c]
                    if nested:
                        row_col_dict[offsets] = (
                            GridLayoutManager.to_row_col_dict(
                                inner_view_and_locs,
                                None,
                                nesting_level, nested))
                    else:
                        row_col_dict.update(
                            GridLayoutManager.to_row_col_dict(
                                inner_view_and_locs,
                                None,
                                nesting_level, nested))
                else:
                    loc_offsets = LocOffsets(*offsets)
                    value = view_and_loc.model.data.values.loc[i, c]
                    style = view_and_loc.model.data.style.loc[i, c]
                    row_col_dict[loc_offsets] = ValueAndStyleAttributes(
                        value, style, nesting_level)

        return row_col_dict


# Core Library Functions

class PresentationLayoutManager:

    @staticmethod
    def apply(f, df):
        df = pd.DataFrame(index=df.index, columns=df.columns)
        for i, c in product(df.index.values, df.columns.values):
            df.loc[i, c] = f(i, c)
        return df

    @staticmethod
    def resolve_loc(presentation_model, offsets=(0, 0, 0, 0), nesting_level=0):
        '''
        Return a DF View with cell populated with ((r,c),(r,c)) range.
        '''

        df_view = presentation_model.data.values
        header = presentation_model.header
        index_label = presentation_model.index_label

        col_widths = PresentationLayoutManager.widths(presentation_model.data.values)
        row_hts = PresentationLayoutManager.heights(presentation_model.data.values)
        header_length = (1 if not hasattr(df_view.columns, 'levels')
                         else len(df_view.columns.levels))
        index_length = (1 if not hasattr(df_view.index, 'levels')
                        else len(df_view.index.levels))

        if presentation_model.kwargs['hide_index']:
            index_length = 0
        if presentation_model.kwargs['hide_header']:
            header_length = 0

        index_name_loc = None
        if (header_length != 0 and index_length != 0):
            index_name_loc = (
                offsets[0],
                offsets[1],
                offsets[0] + header_length - 1,
                offsets[1] + index_length - 1)

        # handle columns
        header_loc = None
        if header_length != 0:
            header_offsets = tuple(
                x + index_length if i % 2 != 0 else x for i, x in enumerate(offsets))
            header_loc = IndexNode.resolve_loc(
                header.values, header_offsets, col_widths)

        # handle index
        index_loc = None
        if index_length != 0:
            index_offsets = tuple(
                x + header_length if i % 2 == 0 else x for i, x in enumerate(offsets))
            index_loc = IndexNode.resolve_loc_vertical(
                index_label.values, index_offsets, row_hts)

        # handle the df
        df_offsets = tuple(x + header_length if i % 2 == 0 else x + index_length
                           for i, x in enumerate(offsets))

        start_row, start_col, end_row, end_col = df_offsets
        df = pd.DataFrame(index=df_view.index, columns=df_view.columns)

        for i in df.index.values:
            end_col, start_col = df_offsets[1], df_offsets[1]
            for c in df.columns.values:
                end_row = start_row + row_hts[i] - 1
                end_col = start_col + col_widths[c] - 1
                df.loc[i, c] = (start_row, start_col, end_row, end_col)
                if isinstance(df_view.loc[i, c], PresentationModel):
                    inner_df = PresentationLayoutManager.resolve_loc(
                        df_view.loc[i, c],
                        (start_row, start_col, start_row, start_col),
                        nesting_level + 1)
                    df.loc[i, c] = inner_df
                start_col = end_col + 1
            start_row = end_row + 1
        locs = Locs(
            header_loc=header_loc,
            index_loc=index_loc,
            data_loc=df,
            index_name_loc=index_name_loc,
            nesting_level=nesting_level)
        return PresentationAndLoc(model=presentation_model, locs=locs)

    @staticmethod
    def shift_loc(presentation_and_loc, rows=0, cols=0):
        '''
        Return a DF View with cell populated with ((r,c),(r,c)) range.
        '''

        new_header_loc = None
        if presentation_and_loc.locs.header_loc:
            new_header_loc = IndexNode.shift_loc(
                presentation_and_loc.locs.header_loc, rows, cols)

        new_index_loc = None
        if presentation_and_loc.locs.index_loc:
            new_index_loc = IndexNode.shift_loc(
                presentation_and_loc.locs.index_loc, rows, cols)

        new_index_name_loc = None
        if presentation_and_loc.locs.index_name_loc:
            new_index_name_loc = tuple(
                x + rows if i % 2 == 0 else x + cols
                for i, x in enumerate(presentation_and_loc.locs.index_name_loc))

        data_loc = presentation_and_loc.locs.data_loc
        df = pd.DataFrame(index=data_loc.index, columns=data_loc.columns)
        for i in df.index.values:
            for c in df.columns.values:
                # FIXME: instance(xx, PresentationAndLoc) is not working right now
                if hasattr(data_loc.loc[i, c], 'locs'):
                    inner_view_and_loc = data_loc.loc[i, c]
                    df.loc[i, c] = PresentationLayoutManager.shift_loc(
                        inner_view_and_loc,
                        rows, cols)
                else:
                    df.loc[i, c] = (data_loc.loc[i, c][0] + rows,
                                    data_loc.loc[i, c][1] + cols,
                                    data_loc.loc[i, c][2] + rows,
                                    data_loc.loc[i, c][3] + cols)

        return PresentationAndLoc(
            model=presentation_and_loc.model,
            locs=Locs(header_loc=new_header_loc,
                      index_loc=new_index_loc,
                      data_loc=df,
                      index_name_loc=new_index_name_loc,
                      nesting_level=presentation_and_loc.locs.nesting_level))
        # return (new_index_loc_view, new_header_loc_view, df,
        # new_index_name_loc)

    @staticmethod
    def widths(df_view):
        col_widths = {}
        for col in df_view.columns:
            s = df_view[col]
            max_width = 1
            for v in s.values:
                if isinstance(v, PresentationModel):
                    inner_width = PresentationLayoutManager.width(
                        v.data.values, v.kwargs['hide_index'])
                    max_width = max(max_width, inner_width)
            col_widths[col] = max_width
        return col_widths

    @staticmethod
    def heights(df_view):
        row_hts = {}
        for i, r in df_view.iterrows():
            max_ht = 1
            for v in r.values:
                if isinstance(v, PresentationModel):
                    inner_ht = PresentationLayoutManager.height(
                        v.data.values, v.kwargs['hide_header'])
                    max_ht = max(max_ht, inner_ht)
            row_hts[i] = max_ht
        return row_hts

    @staticmethod
    def width(df_view, hide_index):
        widths = PresentationLayoutManager.widths(df_view)
        w = 0
        if not hide_index:
            w = (1 if not hasattr(df_view.index, 'levels')
                 else len(df_view.index.levels))
        return sum(w for w in widths.values()) + w

    @staticmethod
    def height(df_view, hide_header):
        heights = PresentationLayoutManager.heights(df_view)
        col_ht = 0
        if not hide_header:
            col_ht = (1 if not hasattr(df_view.columns, 'levels')
                      else len(df_view.columns.levels))
        return sum(w for w in heights.values()) + col_ht

class IndexNode:

    def __init__(self, *, value=None, parent=None, data=None, old_data=None, key=None):
        self.value = value
        self.children = []
        self.parent = parent
        self.data = data  # this is a placehold for clients
        self.old_data = old_data
        self.key = key

    def add_children(self, child_node):
        self.children.extend(child_node)
        for c in self.children:
            c.parent = self

    @staticmethod
    def set_index(tree):
        IndexNode._apply_by_post_pre(
            IndexNode.build_index, tree, order='pre', attr='key')

    @staticmethod
    def accumulate_values(node):
        if not node.parent.parent:
            return (node.value,)
        return (*IndexNode.accumulate_values(node.parent),
                node.value)

    @staticmethod
    def build_index(node):
        if not node.parent.parent:
            return (node.value,)
        return (*IndexNode.accumulate_values(node.parent),
                node.value)

    @staticmethod
    def index(node):
        if not node.parent.parent:
            x = (node.value,)
            assert node.key == x
            return node.key
        x = (*IndexNode.accumulate_values(node.parent),
             node.value)
        assert x == node.key
        return node.key

    @staticmethod
    def leaf_count(node, col_widths):
        # this is for single hierarchical columns
        if not node.children and not node.parent.parent:
            return col_widths[node.value]
        # multi-hierarchicial columns/index

        # leaf in a multi-heirarchical index/column
        if not node.children and node.parent.parent:
            return col_widths[IndexNode.index(node)]
        # FIXME: may not need this condition, for in-between nodes
        if node.children and len(node.children[0].children) == 0:
            return sum(col_widths[IndexNode.index(c)] for c in node.children)
        return sum(IndexNode.leaf_count(n, col_widths) for n in node.children)

    @staticmethod
    def clone(node):
        return IndexNode(
            value=node.value,
            parent=node.parent,
            key=node.key,
            old_data=node.data)

    @staticmethod
    def deep_clone(node):
        new_node = IndexNode.clone(node)
        new_node.add_children([IndexNode.deep_clone(n)
                               for n in node.children])
        return new_node

    @staticmethod
    def _apply_by_level(f, root):
        if not root.parent:
            q = deque(root.children)
        else:
            q = deque([root])

        while q:
            n = q.popleft()
            n.data = f(n)
            q.extend(n.children)

    @staticmethod
    def _apply_by_post_pre(f, root, order, attr='data'):
        if root.parent and order == 'pre':
            setattr(root, attr, f(root))

        for c in root.children:
            IndexNode._apply_by_post_pre(f, c, order, attr)

        if root.parent and order == 'post':
            setattr(root, attr, f(root))

    @staticmethod
    def apply(f, root, order='post'):
        '''
        root: root of the hierarchical columns/index
        order: apply in pre-order or post-order or inorder
        '''
        # clone whole tree
        new_root = IndexNode.deep_clone(root)

        if order == 'level':
            IndexNode._apply_by_level(f, new_root)
        else:
            IndexNode._apply_by_post_pre(f, new_root, order)
        return new_root

    @staticmethod
    def index_to_index_node(index):
        '''
        Convert a column index to a tree view that can be used
        for rendering

        index: usually df.columns, can all support df.index
        '''

        root = IndexNode()
        if not isinstance(index.values[0], tuple):
            # not an multi-index
            root.add_children(IndexNode(value=i, parent=root, key=(i,))
                              for i in index.values)
            return root

        # multi hierarchical index
        values = list(zip(*index.labels))
        tree = IndexNode._build_tree(index, values, level=0)
        root.add_children(tree)

        IndexNode.set_index(root)
        return root

    @staticmethod
    def _build_tree(index, indices, level=0):
        '''
        Build a tree of IndexNode that is a tree representtion of
        pandas multi-index
        '''
        grps = groupby(indices, key=lambda x: x[0])
        nodes = []
        for k, g in grps:
            g = list(g)
            if len(g[0]) == 1:
                # leaf node
                for i in g:
                    nodes.append(IndexNode(value=index.levels[level][i[0]]))
            else:
                next_level = [i[1:] for i in g]
                children = IndexNode._build_tree(
                    index, next_level, level + 1)
                parent = IndexNode(value=index.levels[level][k])
                parent.add_children(children)
                nodes.append(parent)
        return nodes

    @staticmethod
    def shift_loc(node, rows=0, cols=0):
        def _shift_loc(node):
            return (node.old_data[0] + rows,
                    node.old_data[1] + cols,
                    node.old_data[2] + rows,
                    node.old_data[3] + cols)

        return IndexNode.apply(_shift_loc, node)

    # FIXME: offsets can be explicit start_row and start_col
    @staticmethod
    def resolve_loc(tree, offsets, col_widths):
        '''
        Args:
        col_widths: dictionary of column width of each column, indexed by
        column key. For multi-hierarchical columns the key would a tuple
        where the tuple is the unique index into the column. Eg {('a', 1): 10}
        '''

        # make this immutable
        original_offsets = offsets
        current_offsets = [x for x in original_offsets]
        previous_level = 1

        def _resolve_loc(node):
            nonlocal current_offsets
            nonlocal previous_level
            level = len(IndexNode.index(node))
            n_children = IndexNode.leaf_count(node, col_widths)
            n_children = max(1, n_children)
            if level == previous_level:
                new_offsets = [current_offsets[0],
                               current_offsets[1],
                               current_offsets[0],
                               current_offsets[1] + n_children - 1]
                current_offsets = _shift_cols(new_offsets)
            else:
                new_offsets = [current_offsets[0] + 1,
                               original_offsets[1],
                               current_offsets[0] + 1,
                               original_offsets[1] + n_children - 1]
                previous_level = level
                current_offsets = _shift_cols(new_offsets)
            return tuple(new_offsets)

        return IndexNode.apply(_resolve_loc, tree, order='level')

    # FIXME: offsets can be explicit start_row and start_col
    @staticmethod
    def resolve_loc_vertical(tree, offsets, row_hts):

        # make this immutable

        original_offsets = offsets
        current_offsets = [x for x in original_offsets]
        previous_level = 1

        def _resolve_loc(node):
            #import ipdb; ipdb.set_trace()
            nonlocal current_offsets
            nonlocal previous_level
            level = len(IndexNode.index(node))
            n_children = IndexNode.leaf_count(node, row_hts)
            n_children = max(1, n_children)
            if level == previous_level:
                new_offsets = [current_offsets[0],
                               current_offsets[1],
                               current_offsets[0] + n_children - 1,
                               current_offsets[1]]
                current_offsets = _shift_row(new_offsets)
            else:
                new_offsets = [original_offsets[0],
                               current_offsets[1] + 1,
                               original_offsets[0] + n_children - 1,
                               current_offsets[1] + 1]
                previous_level = level
                current_offsets = _shift_row(new_offsets)
            #print(node.value, new_offsets)
            return tuple(new_offsets)

        return IndexNode.apply(_resolve_loc, tree, order='level')

    @staticmethod
    def gather_data(*trees):
        '''
        Returns a dict index by index and all data attributes
        from all trees
        '''
        data = defaultdict(list)

        def _gather_data(node):
            data[IndexNode.index(node)].append(node.old_data)

        for t in trees:
            IndexNode.apply(_gather_data, t)
        return data


def _shift_cols(offset):
    return (offset[0], offset[3] + 1, offset[2], offset[3] + 1)


def _shift_row(offset):
    return (offset[2] + 1, offset[1], offset[2] + 1, offset[3])


# Helper functions to test the library

# def sample_value_view_func(df, i, column):
#     return df.loc[i, column]


# def sample_header_value_view_func(node):
#     return node.value


# def sample_apply(node):
#     x = IndexNode.accumulate_values(node)
#     print(x)
#     return x


# def get_sample_views(df, embedded=False):

#     x = build_presentation_model(df=df, data_value_func=lambda i, c: sample_value_view_func(
#         df, i, c), header_value_func=sample_header_value_view_func)
#     if embedded:
#         x1 = build_presentation_model(df=df, data_value_func=lambda i, c: sample_value_view_func(
#             df, i, c), header_value_func=sample_header_value_view_func)
#         x.data.values.loc[2, 'b'] = x1
#     return x


# def get_sample_multicol_df(embedded=False):
#     df = pd.DataFrame(
#         data=dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[1, 2, 3])
#     df2 = pd.concat([df.copy(), df.copy()], axis=1)
#     df2.columns = pd.MultiIndex.from_product([['a', 'b'], ['x', 'y', 'z']])
#     df2 = df2 * 0
#     #df2.index.name = 'outer_index'

#     df3 = pd.concat([df.copy(), df.copy()], axis=1)
#     df3.columns = pd.MultiIndex.from_product(
#         [['a1', 'b1'], ['x1', 'y1', 'z1']])
#     df3.index.name = 'inner_index'

#     # #df3 = df.copy()
#     # df3 = df3[[('a1', 'x1'), ('a1','y1')]]
#     # df3 = df3 * 100

#     #df4 = df.copy()
#     #df3.columns = pd.MultiIndex.from_product([['a1', 'b1'], ['x1', 'y1', 'z1']])

#     def df1_header_style(node):
#         if len(node.key) > 1:
#             color = '9BC2E6'
#         else:
#             color = 'A9D08E'
#         return OpenPyxlHelper.get_style(bg_color=color)

#     def df1_number_format(df, i, c):
#         number_format = '_($* #,##0_);_($* (#,##0);_($* "-"??_);_(@_)'
#         if c == ('a', 'x'):
#             return OpenPyxlHelper.get_style(number_format=number_format)
#         return OpenPyxlHelper.get_style()

#     views = build_presentation_model(
#         df=df2,
#         data_value_func=lambda i, c: sample_value_view_func(df2, i, c),
#         style_func=lambda i, c: df1_number_format(df2, i, c),
#         header_value_func=sample_header_value_view_func,
#         header_style_func=df1_header_style)

#     views2 = build_presentation_model(
#         df=df3,
#         data_value_func=lambda i, c: sample_value_view_func(df3, i, c),
#         header_value_func=sample_header_value_view_func)

#     if embedded:
#         views.data.values.loc[2, ('a', 'y')] = views2
#     return views


# def test_df_with_style(embedded=False):

#     df = pd.DataFrame(
#         data=dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[1, 2, 3])
#     df2 = pd.concat([df.copy(), df.copy()], axis=1)
#     df2.columns = pd.MultiIndex.from_product([['a', 'b'], ['x', 'y', 'z']])
#     df2.index.name = 'outer_index'

#     df3 = pd.concat([df.copy(), df.copy()], axis=1)
#     df3.columns = pd.MultiIndex.from_product(
#         [['a1', 'b1'], ['x1', 'y1', 'z1']])
#     df3.index.name = 'inner_index'

#     def df1_header_style(node):
#         if len(node.key) > 1:
#             color = '9BC2E6'
#         else:
#             color = 'A9D08E'
#         return OpenPyxlHelper.get_style(bg_color=color)

#     views = build_presentation_model(
#         df=df2,
#         data_value_func=lambda i, c: sample_value_view_func(df2, i, c),
#         header_value_func=sample_header_value_view_func,
#         header_style_func=df1_header_style)

#     views2 = build_presentation_model(
#         df=df3,
#         data_value_func=lambda i, c: sample_value_view_func(df3, i, c),
#         header_value_func=sample_header_value_view_func)

#     if embedded:
#         views['values'][1].loc[2, ('a', 'y')] = (views2['values'])
#         views['styles'][1].loc[2, ('a', 'y')] = (views2['styles'])

#     row_col_dict = render(views)
#     to_excel_from_row_col_dict(row_col_dict)


# def test1():

#     df = pd.DataFrame(data=dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]))

#     m = build_presentation_model(
#         df=df,
#         data_value_func=lambda i, c: sample_value_view_func(df, i, c),
#         header_value_func=sample_header_value_view_func)

#     shifted_grid = GridLayoutManager.resolve_grid([m])
#     to_excel_from_row_col_dict(
#         GridLayoutManager.to_row_col_dict_from_grid(shifted_grid))


# def test2():
#     df = pd.DataFrame(data=dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]))
#     m = get_sample_views(df, embedded=True)
#     m1 = get_sample_multicol_df(embedded=True)
#     shifted_grid = GridLayoutManager.resolve_grid([[m, m1], [m1, m]])
#     to_excel_from_row_col_dict(
#         GridLayoutManager.to_row_col_dict_from_grid(shifted_grid))


# def to_html(d):

#     def wrap_tr(d, k, v):
#         s = ""
#         for i in v:
#             s = s + "<td>" + str(d[i][0]) + "</td>"
#         s = "<tr>\n" + s + "\n</tr>\n"
#         return s

#     for k, v in groupby(sorted(d), key=lambda x: (x[0])):
#         print("<html>\n")
#         print(wrap_tr(d, k, v))
#         print("</html>")
